package printer

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/davyxu/tabtoy/util"
	"github.com/davyxu/tabtoy/v2/i18n"
	"github.com/davyxu/tabtoy/v2/model"
)

func valueWrapperLua(g *Globals, t model.FieldType, n *model.Node) string {

	switch t {
	case model.FieldType_String, model.FieldType_Text:
		return util.StringEscape(n.Value)
	case model.FieldType_Key:
		// 暂时用int64的方式来解析key
		_, err := strconv.ParseInt(n.Value, 10, 64)

		// 不等于0 则认为是str key
		if err != nil {
			return util.StringEscape(n.Value)
		}
	case model.FieldType_Enum:
		if g.LuaEnumIntValue {
			return fmt.Sprintf("%d", n.EnumValue)
		} else {
			return fmt.Sprintf("\"%s\"", n.Value)
		}

	}

	return n.Value
}

type luaPrinter struct {
}

func (self *luaPrinter) Run(g *Globals, outputClass int) *Stream {

	stream := NewStream()

	stream.Printf("-- Generated by github.com/davyxu/tabtoy\n")
	stream.Printf("-- Version: %s\n", g.Version)

	if g.LuaTabHeader != "" {
		stream.Printf("\n%s\n", g.LuaTabHeader)
	}

	if !printTitleLua(g, stream, outputClass) {
		return nil
	}

	stream.Printf("\nlocal data = {\n")

	for tabIndex, tab := range g.Tables {
		if !tab.LocalFD.MatchTag(".lua") {
			log.Infof("%s: %s", i18n.String(i18n.Printer_IgnoredByOutputTag), tab.Name())
			continue
		}

		if !printTableLua(g, stream, tab, outputClass) {
			return nil
		}

		// 根字段分割
		if tabIndex < len(g.Tables)-1 {
			stream.Printf(", ")
		}

		// stream.Printf("\n")
	}

	// local tab = {
	stream.Printf("}\n")

	// if !genLuaIndexCode(stream, g.CombineStruct) {
	// 	return stream
	// }

	// 生成枚举
	// if !genLuaEnumCode(g, stream, g.FileDescriptor) {
	// 	return stream
	// }

	stream.Printf("\nreturn {data, title}")

	return stream
}

// 打印标题
func printTitleLua(g *Globals, stream *Stream, outputClass int) bool {
	stream.Printf("local title = {")

	nodes := g.Tables[0].Recs[0].Nodes
	length := len(nodes)
	var str string
	var i = 1
	var hasKey = false
	for index, node := range nodes {
		// 客户端导出类型
		if outputClass == 1 {
			if !node.ExportClient {
				continue
			}
		}

		// 服务器导出类型
		if outputClass == 2 {
			if !node.ExportServer {
				continue
			}
		}

		// key值类型 导出直接为索引
		if node.IsKey {
			if !hasKey {
				hasKey = true
				continue
			} else {
				log.Errorf("只允许有一列使用|key, %s", node.Name)
				return false
			}
		}

		name := strings.TrimFunc(node.Name, IsBom)
		str = "[" + "'" + name + "'" + "]=" + strconv.Itoa(i)
		i = i + 1
		if index != length-1 {
			str = str + ","
		}
		stream.Printf(str)
	}

	stream.Printf("}")

	return true
}

func IsBom(r rune) bool {
	if uint32(r) == 65279 {
		return true
	} else {
		return false
	}
}

func printTableLua(g *Globals, stream *Stream, tab *model.Table, outputClass int) bool {
	// 遍历每一行
	for rIndex, r := range tab.Recs {
		var hasKey = false
		// 要先看看是否需要key值索引
		for _, node := range r.Nodes {
			// 如果有key 就需要根据key值去索引
			if node.IsKey {
				// 只允许有一个key
				if !hasKey {
					hasKey = true
				} else {
					log.Errorf("只允许有一列使用|key, %s", node.Name)
					return false
				}

				if node.Type != model.FieldType_Struct && !node.IsRepeated {
					valueNode := node.Child[0]
					stream.Printf("["+"%s"+"]=", valueWrapperLua(g, node.Type, valueNode))
				} else {
					log.Errorf("不支持结构体或数组为key！")
					return false
				}

			}
		}

		// 每一行开始
		stream.Printf("{ ")

		// 遍历每一列
		for rootFieldIndex, node := range r.Nodes {

			// 客户端导出类型
			if outputClass == 1 {
				if !node.ExportClient {
					continue
				}
			}

			// 服务器导出类型
			if outputClass == 2 {
				if !node.ExportServer {
					continue
				}
			}
			name := strings.TrimFunc(node.Name, IsBom)
			if node.IsRepeated {
				stream.Printf("%s = {", name)
			} else {
				stream.Printf("%s = ", name)
			}

			// 普通值
			if node.Type != model.FieldType_Struct {

				if node.IsRepeated {
					length := len(node.Child)
					// repeated 值序列
					for arrIndex, valueNode := range node.Child {
						stream.Printf("%s", valueWrapperLua(g, node.Type, valueNode))
						// 多个值分割
						if arrIndex < len(node.Child)-1 && valueNode.Value != "{" && ((arrIndex+1 < length) && node.Child[arrIndex+1].Value != "}") {
							stream.Printf(", ")
						}

					}
				} else {
					// 单值
					valueNode := node.Child[0]

					stream.Printf("%s", valueWrapperLua(g, node.Type, valueNode))
				}

			} else {

				// 遍历repeated的结构体
				for structIndex, structNode := range node.Child {

					// 结构体开始
					stream.Printf("{")

					// 遍历一个结构体的字段
					for structFieldIndex, fieldNode := range structNode.Child {

						// 值节点总是在第一个
						valueNode := fieldNode.Child[0]

						stream.Printf("%s=%s", fieldNode.Name, valueWrapperLua(g, fieldNode.Type, valueNode))

						// 结构体字段分割
						if structFieldIndex < len(structNode.Child)-1 {
							stream.Printf(",")
						}

					}

					// 结构体结束
					stream.Printf("}")

					// 多个结构体分割
					if structIndex < len(node.Child)-1 {
						stream.Printf(",")
					}

				}

			}

			if node.IsRepeated {
				stream.Printf("}")
			}

			// 根字段分割
			if rootFieldIndex < len(r.Nodes)-1 {
				stream.Printf(", ")
			}

		}

		// 每一行结束
		stream.Printf(" }")

		if rIndex < len(tab.Recs)-1 {
			stream.Printf(",")
		}

		stream.Printf("\n")

	}

	return true

}

func anyFieldOutput(d *model.Descriptor) bool {
	for _, fd := range d.Fields {
		if fd.Meta.GetBool("LuaValueMapperString") {
			return true
		}

		if fd.Meta.GetBool("LuaStringMapperValue") {
			return true
		}

	}

	return false
}

// 收集需要构建的索引的类型
func genLuaEnumCode(g *Globals, stream *Stream, globalFile *model.FileDescriptor) bool {

	stream.Printf("\ntab.Enum = {\n")

	// 遍历字段
	for _, d := range globalFile.Descriptors {

		if d.Kind != model.DescriptorKind_Enum {
			continue
		}

		if anyFieldOutput(d) {
			stream.Printf("	%s = {\n", d.Name)

			for _, fd := range d.Fields {

				if fd.Meta.GetBool("LuaValueMapperString") {
					stream.Printf("		[%d] = \"%s\",\n", fd.EnumValue, fd.Name)
				}

			}

			for _, fd := range d.Fields {

				if fd.Meta.GetBool("LuaStringMapperValue") {
					stream.Printf("		%s = %d,\n", fd.Name, fd.EnumValue)
				}

			}

			stream.Printf("	},\n")
		}

	}

	stream.Printf("}\n")

	return true

}

// 收集需要构建的索引的类型
func genLuaIndexCode(stream *Stream, combineStruct *model.Descriptor) bool {

	// 遍历字段
	for _, fd := range combineStruct.Fields {

		// 这个字段被限制输出
		if fd.Complex != nil && !fd.Complex.File.MatchTag(".lua") {
			continue
		}

		// 对CombineStruct的XXDefine对应的字段
		if combineStruct.Usage == model.DescriptorUsage_CombineStruct {

			// 这个结构有索引才创建
			if fd.Complex != nil && len(fd.Complex.Indexes) > 0 {

				// 索引字段
				for _, key := range fd.Complex.Indexes {
					mapperVarName := fmt.Sprintf("tab.%sBy%s", fd.Name, key.Name)

					stream.Printf("\n-- %s\n", key.Name)
					stream.Printf("%s = {}\n", mapperVarName)
					stream.Printf("for _, rec in pairs(tab.%s) do\n", fd.Name)
					stream.Printf("\t%s[rec.%s] = rec\n", mapperVarName, key.Name)
					stream.Printf("end\n")
				}

			}

		}

	}

	return true

}

func init() {

	RegisterPrinter("lua", &luaPrinter{})

}
